---
index: 1
---

# 渲染机制

`Preezid` 的渲染分为三层, `lts 编译` 阶段和 `EffectMapper 更新` 阶段.

## `lts 编译` 阶段

`lts 编译` 阶段负责将 `lts` 代码转换成 `HTML DOM` 字符串, 该阶段由 `Preezid Dev`, `Preezid Compiler` 和 `PiteRender` 三个部分协同完成.

该阶段会进行以下工作:

1. 自动注册:
    
    服务器启动时, `Preezid Dev` 将会将所有文件加载到内存中, 之后扫描所有文件, 自动注册组件和页面等资源到根文件中.
    
2. 自动导入:

    自动注册之后, `Preezid Dev` 会根据代码中的引用关系, 再各个文件中自动导入所需的组件和页面等资源.

3. 静态编译:

    注册导入结束后, `Preezid Compiler` 分析 `lts` 代码中静态和动态的全部内容, 对于静态内容, 直接编译为 `HTML DOM` 字符串, 对于动态内容, 则编译为 `PiteRender TS` 代码.

    例如:
    
    ```lts
    load {
      div.class("container").style({ backgroundColor: "#00aaff" }) {
        arr.value.forEach(item => {
          span.style({ color: item.color }) { item.name }
        })
        
        for (const _item of arr.value) {
          span { "我是本文" }
        }
        
        button.@click(handleClick) { "Click me !" }
      }
    }
    ```
    
    它将被编译为:
    
    ```ts
    render("div")
      .attr("class=\"container\" style=\"background-color: #00aaff\"")
      .slot([
        () => {
          arr.value.forEach(item => {
            return render("span").style(item.color).slot(item.name).build()
          })
        },
        () => {
          for (const _item of arr.value) {
            return render("span").slot("我是文本").build()
          }
        },
        render("button").attr("onclick=\"handleClick\"").slot("Click me !").build(),
      ])
      .build()
    ```

4. 运行时编译:

    之后, `PiteRender` 运行 `PiteRender TS` 代码, 使用内置的 `render` 类, 构建最终的 DOM 字符串.

    ```html
    <div class="container" style="background-color: #00aaff">
      <!-- 这里具体根据 arr 内容来渲染 -->
      <span>...</span>
      <span>...</span>
      <button onclick="handleClick">Click me !</button>
    ```

## `EffectMapper 更新` 阶段

`Preezid` 中的静态内容会被 `Preezid Compiler` 阶段直接编译为静态的 `HTML DOM` 字符串, 因此无需更新.

而动态内容, 分为如下几种:

1. 内容或属性直接依赖响应式变量的节点 `DynamicSelf`
2. 处于动态上下文的节点 `DynamicScope`
3. 含有动态子节点的直接父节点 `DynamicParent`
4. 同级含有动态节点的节点 `DynamicSibling`

例如上述的 `PiteRender TS` 代码:

```ts
render("div")
  // 属于第一类和第三类动态节点
  .attr("class=\"container\" style=\"background-color: #00aaff\"")
  .slot([
    () => {
      arr.value.forEach(item => {
        // 属于第一类和第二类动态节点
        return render("span").style(item.color).slot(item.name).build()
      })
    },
    () => {
      for (const _item of arr.value) {
        // 属于第二类动态节点
        return render("span").slot("我是文本").build()
      }
    },
    // 属于第四类动态节点
    render("button").attr("onclick=\"handleClick\"").slot("Click me !").build(),
  ])
  .build()
```

`PiteRender` 会使用 `data-id` 标记动态节点, 之后 `EffectMapper` 会构建响应式变量与动态节点 `key` 的映射关系, 以及按类型的构建各个节点的更新方法.

```ts
type DynamicPiteNodeType = 
  | "DynamicSelf"               // 第一类: 内容或属性直接依赖响应式变量的节点
  | "DynamicScope"              // 第二类: 处于动态上下文的节点
  | "DynamicParent"             // 第三类: 含有动态子节点的直接父节点
  | "DynamicSibling"            // 第四类: 同级含有动态节点的节点

interface DynamicPiteNode {
  key: string
  type: DynamicPiteNodeType[]
  update: record<string, DynamicUpdateFunction>
}

interface DynamicUpdateFunction extends Function {}
```

具体详见 响应式系统 章节.
