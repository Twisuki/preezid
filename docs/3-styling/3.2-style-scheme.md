---
index: 2
---

# 样式方案

由于前端样式方案众多, 且各有优缺点, 因此 `Preezid` 并未找到一个完全合适的方案作为样式方案, 因此, `Preezid` 提供了多种方案选择.

## 结构化 CSS 方案

`Preezid` 完全支持原生的 CSS 语法, 但原生 CSS 需要大量的类选择器, 命名混乱难以维护, 因此, `Preezid` 在原有 CSS 嵌套的基础上, 提供了一套结构化 CSS 方案.

`Preezid` 希望单逻辑单文件少嵌套, 因此, 对于每一组逻辑, 只需在根节点添加类名, 并使用 CSS 选择, 其余样式则使用相同的结构与 DOM 树对应即可.

例如:

```lts
load {
  button.class("button").*warpper { div }
  { span { 我是按钮 } }
}

style {
  .button {
    ::warpper {
      width: 6rem;
      height: 2rem;
      display: flex;
      justify-content: center;
      items-align: center;
    }
    
    & {
      background-color: #5c77ff;
      display: flex;
      justify-content: center;
      items-align: center;
      
      :hover {
        transform: translateY(-0.2rem);
      }
      
      :avtive {
        background-color: #5cdfff;
      }
      
      & span {
        font-size: 1.2rem;
        color: white;
      }
    }
  }
}
```

_注意: 依赖节点使用类似 CSS 伪元素的写法作为选择器, 例如 `::warpper`, `::pivot`._

_如 `::warpper` 存在多个依赖节点时, 使用 `::warpper[index]` 来进行选择, 或在此基础上绑定 `class`._

`Preezid CSS` 有如下特殊选择器:

- `::node` 拓展伪元素: 依赖节点选择器, 按类型选择依赖节点, 例如 `::warpper`, `::before`, `::after`, `::pivot`.
- `[index]` 索引选择器, 选择满足条件的索引, 和 CSS `.nth-child()` 类似, 但更直观, 例如: `.button[1]`, 选择第二个 class 为 button 的节点; `.content[3n]`, 选择 class 为 content 的节点中, 索引为 3 的倍数的节点.
- `&` 结构选择器, 在嵌套结构中, 代表当前选择器本身, `& innerDOM` 代表当前选择器下的 `innerDOM` 子节点.

`Preezid 结构化 CSS` 使用规范如下:

1. 每个逻辑单元的根节点必须有一个唯一的类名, 作为该逻辑单元的标识.
2. 若存在依赖节点, 则将依赖节点的样式写在最上面, 以 `::node` 选择器开头, 不加 `&`.
3. 其余样式均写在 `&` 选择器下, 以保持结构清晰(若不存在依赖节点, 则直接编写样式, 不再使用 `&`).
4. `&` 表示分级关系, 因此, 绑定在本节点的伪类, 不使用 `&` 开头, 子节点才使用 `&` 开头.

## 原子化 CSS 方案

在 `Tailwind CSS` 和其他 CSS 框架的影响下, 原子化 CSS 方案越来越流行. `Preezid` 也提供了 `Preezid Atomic CSS` 工具以支持原子化 CSS 方案.

不同的是, `Preezid` 希望样式与类独立, 因此, `Preezid Atomic CSS` 为标签引入了一个新属性 `.acss()`, 用于绑定原子化 CSS 类.

```lts
load {
  button
    .acss("flex justify-center items-center bg-primary hover:translate-y--0.2 active:bg-secondary")
    .*warpper { div.acss("w-12 h-4 flex justify-center items-center") }
    { span.acss("text-white") { 我是按钮 } }
}
```

此外, 也可以使用 `A()` 方法将原子化 CSS 样式直接写入到 `.style()` 属性中.

```lts
load {
  button
    .style(A("flex justify-center items-center bg-primary hover:translate-y--0.2 active:bg-secondary"))
    .*warpper { div.style(A("w-12 h-4 flex justify-center items-center")) }
    { span.style(A("text-white")) { 我是按钮 } }
}
```

_注意: 使用原子化 CSS 方案, 请另行安装 `Preezid Atomic CSS` 工具和对应的原子化 CSS 库._

## CSS-in-JS 方案

与 React 相同, `Preezid` 可在 `.style()` 属性中直接编写样式对象.

```lts
load {
  button
    .style({
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      backgroundColor: "#5c77ff",
      hover: {
        transform: "translateY(-0.2rem)"
      },
      active: {
        backgroundColor: "#5cdfff"
      }
    })
    .*warpper {
      div.style({
        width: "6rem",
        height: "2rem",
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      })
    }
    {
      span.style({
        fontSize: "1.2rem",
        color: "white"
      }) {
        我是按钮
      }
    }
}
```

但我们并不推荐内联方案, `Preezid` 可将样式对象使用声明式的方式写入到 `style(module S)` 标签中, 之后使用 `.style()` 调用.

_尽管写法与结构化 CSS 几乎完全相同, 但内部处理上有很大区别, 此外, CSS-in-JS 方案是 DOM 绑定 style, 而非原生 CSS 的 style 寻找同名 DOM, 性能和逻辑上都更接近函数式._

```lts
load {
  button.style(S.button).*warpper { div.style(S.buttonWarpper) }
  { span.style(S.buttonSpan) { 我是按钮 } }
}

style(module S) {
  button-warpper {
    width: 6rem;
    height: 2rem;
    display: flex;
    justify-content: center;
    items-align: center;
  }
  
  button {
    background-color: #5c77ff;
    display: flex;
    justify-content: center;
    items-align: center;
    
    :hover {
      transform: translateY(-0.2rem);
    }
    
    :avtive {
      background-color: #5cdfff;
    }
  }
  
  button-span {
    font-size: 1.2rem;
    color: white;
  }
}
```

此外, `style module` 也推荐结构化 CSS 方案, 只需在根 DOM 绑定一组 style 对象即可:

```lts
load {
  button.style(S.button).*warpper { div }
  { span { 我是按钮 } }
}

style(module S) {
  button {
    ::warpper {
      width: 6rem;
      height: 2rem;
      display: flex;
      justify-content: center;
      items-align: center;
    }
    
    & {
      background-color: #5c77ff;
      display: flex;
      justify-content: center;
      items-align: center;
      
      :hover {
        transform: translateY(-0.2rem);
      }
      
      :avtive {
        background-color: #5cdfff;
      }
      
      & span {
        font-size: 1.2rem;
        color: white;
      }
    }
  }
}
```

> "CSS-in-JS 方案是 DOM 绑定 style, 而非原生 CSS 的 style 寻找同名 DOM", 然而 `style module` 除了根 DOM 外, 依然是 style 匹配 DOM 的模式, 这是否与理念相背?
> 
> 并不.
> 
> `style module` 绑定到根 DOM 上, 意味着整个 style 树的绑定, 只是表现在根 DOM 而已.
