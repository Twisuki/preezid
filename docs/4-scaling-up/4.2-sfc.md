---
index: 2
---

# 单文件组件

## 定义与使用组件

`lts` 中, 子组件将被当作一个自定义的 UI 标签, 写入到父组件中.

例如我们定义一个最简单的组件:

```lts
load {
  span { This is a child component. }
}
```

保存为 `MyComponent.lts` 后, 我们就可以在其他组件中使用它:

```lts
define {
  useLabel("./MyComponent.lts")
}

load {
  div {
    MyComponent
  }
}
```

## 传递 props

组件可以通过 `props` 来接收父组件传递的数据.

`props` 在子组件中是只读的, 此外若传入的是 `statue()` 值, 当父组件中该状态更新时, 子组件也会自动更新.

例如我们在 `MyComponent.lts` 中定义一个 `props`:

```lts
define {
  interface Props {
    text: string
  }

  const props = useProps<Props>().default({
    text: "Default Label"
  })
}

load {
  span { "Label: " + props.text }
}
```

父组件中, 使用标签属性 `.props()` 来传递数据, 或使用简写格式 `!key()`:

```lts
define {
  useLabel("./MyComponent.lts")
  const labelText = status("Hello, Preezid!")
}

load {
  div {
    MyComponent.props({ text: labelText.value })
    MyComponent.!text(labelText.value)
  }
}
```

## 绑定数据

当需要子组件反过来向父组件传递数据时, `react` 和 `vue` 受控组件都需要在父组件内定义一个回调函数, 并将其作为 `prop` 传递给子组件, 这样可以保证数据安全.

此外, `vue` 默认提供了更简单的数据绑定, 但数据绑定并非完全受控, 可能会引发一些不可预期的问题.

`Preezid` 与 `vue` 数据绑定类似, 提供了简单的绑定方案, 但仍然保持数据受控的特性, 即使用 `.bind()` 传递数据.

bind 数据要求父组件中必须传入 `status()` 或 `store()` 创建的响应式状态, 以保证数据的双向更新.

而子组件中, 无论数据如何, 都将在传递时自动升级为 `store()`, 只能使用 `.get()` 和 `.set()` 方法来访问和修改数据.

例如我们在 `MyComponent.lts` 中定义一个 `bind`:

```lts
define {
  interface Bind {
    count: number
  }
  
  const bindStore = useBind<Bind>().default({
    count: 0
  })
  
  const increment = () => {
    bindStore.count.set(bindStore.count.get() + 1)
  }
  
  const reset = () => {
    bindStore.count.set(0)
  }
}

load {
  div {
    button.@click(increment) { "Increment" }
    button.@click(reset) { "Reset" }
  }
}
```

父组件中, 使用标签属性 `.bind()` 来绑定数据, 或使用简写格式 `:key()`:

```lts
define {
  useLabel("./MyComponent.lts")
  const count = status(0)
}

load {
  div {
    MyInput.bind({ count: count })
    MyInput.:count(count)
    p { "Count is: " + count.value }
  }
}
```

## 插槽

`Preezid` 插槽与 `vue` 高度类似.

子组件中, 使用 `slot` 标签来定义插槽, 同时可以声明插槽名称(留空为默认插槽):

```lts
load {
  h1 {
    slot // 默认插槽
  }
  p {
    slot("p")
  }
}
```

父组件中, 使用标签属性 `.slot()` 来传递插槽内容, 或使用简写格式 `#name()`:

```lts
define {
  useLabel("./MyComponent.lts")
}

load {
  div {
    MyComponent.slot() {
      "This is the default slot content."
    }
    .slot("p") {
      "This is the content for the 'p' slot."
    }
    
    MyComponent {
      "This is the default slot content."
      // 默认插槽也可直接使用 {}
    }
    .#p() {
      "This is the content for the 'p' slot."
    }
  }
}
```

## 事件侦听

`Preezid` 组件可使用 `useEvent()` 来自定义事件属性.

```lts
define {
  const count = status(0)
  count.update(() => {
    useEvent("countUpdated").return(count.value)
  })
}

load {
  div {
    button.@click(() => { count.value++ }) { "Count is: " + count.value }
  }
}
```

父组件中, 使用标签属性 `.event()` 来侦听事件, 或使用简写格式 `@name()`:

```lts
define {
  useLabel("./MyComponent.lts")
  
  const handleCountUpdated = (count) => {
    console.log("Count was updated as:", count)
  }
}

load {
  div {
    MyInput.event("countUpdated", handleCountUpdated)
    MyInput.@countUpdated(handleCountUpdated)
  }
}
```

## 依赖组件

组件可使用 `useComponent().dependent(type)` 的方式生命为依赖组件, 例如如下 `warpper` 类型的滚动检测组件:

```lts
define {
  useComponent().dependent("warpper")

  const scrolled = stetus(false)
  const handleScrolled = () => {
    // 视口高度检测函数
  }

  scrolled.update(() => {
    useEvent("scrolled")
  })
}

load {
  div.@scrolled(handleScrolled)
  { slot }
}
```

在父组件中, 该组件将作为 `warpper` 依赖节点使用:

```lts
define {
  useLabel("./MyComponent.lts")
  
  const handleScrolled = () => {
    // 处理滚动事件
  }
}

load {
  div.class(...).style(...)
    .node("warpper") {
      MyComponent.@scrolled(handleScrolled)
    } {
      // 内部 DOM
    }
}
```

其他类似的依赖组件声明方式相同, 但要注意满足各个类型依赖组件的特征, 否则编译时将报错!

## 组件注册

为了方便组件的复用, 我们可以将组件注册到全局组件库中.

直接在组件中, 使用 `useComponent().registry()` 方法注册组件:

```lts
define {
  useComponent().registry("MyComponent") // 留空则使用文件名作为组件名
}
```

然后在其他组件直接使用即可, 无需再使用 `useLabel()` 导入组件.
